!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
A	makefile	/^A=.a$/;"	m
ALLOC	include/mem.h	/^#define ALLOC(/;"	d
AP_INCLUDED	include/ap.h	/^#define AP_INCLUDED$/;"	d
AP_add	src/ap.c	/^T AP_add(T x, T y) {$/;"	f
AP_addi	src/ap.c	/^T AP_addi(T x, long int y) {$/;"	f
AP_cmp	src/ap.c	/^int AP_cmp(T x, T y) {$/;"	f
AP_cmpi	src/ap.c	/^int AP_cmpi(T x, long int y) {$/;"	f
AP_div	src/ap.c	/^T AP_div(T x, T y) {$/;"	f
AP_divi	src/ap.c	/^T AP_divi(T x, long int y) {$/;"	f
AP_fmt	src/ap.c	/^void AP_fmt(int code, va_list *app,$/;"	f
AP_free	src/ap.c	/^void AP_free(T *z) {$/;"	f
AP_fromstr	src/ap.c	/^T AP_fromstr(const char *str, int base, char **end) {$/;"	f
AP_lshift	src/ap.c	/^T AP_lshift(T x, int s) {$/;"	f
AP_mod	src/ap.c	/^T AP_mod(T x, T y) {$/;"	f
AP_modi	src/ap.c	/^long int AP_modi(T x, long int y) {$/;"	f
AP_mul	src/ap.c	/^T AP_mul(T x, T y) {$/;"	f
AP_muli	src/ap.c	/^T AP_muli(T x, long int y) {$/;"	f
AP_neg	src/ap.c	/^T AP_neg(T x) {$/;"	f
AP_new	src/ap.c	/^T AP_new(long int n) {$/;"	f
AP_pow	src/ap.c	/^T AP_pow(T x, T y, T p) {$/;"	f
AP_rshift	src/ap.c	/^T AP_rshift(T x, int s) {$/;"	f
AP_sub	src/ap.c	/^T AP_sub(T x, T y) {$/;"	f
AP_subi	src/ap.c	/^T AP_subi(T x, long int y) {$/;"	f
AP_toint	src/ap.c	/^long int AP_toint(T x) {$/;"	f
AP_tostr	src/ap.c	/^char *AP_tostr(char *str, int size, int base, T x) {$/;"	f
AR	makefile	/^AR=ar ruv$/;"	m
ARENA_INCLUDED	include/arena.h	/^#define ARENA_INCLUDED$/;"	d
ARRAYREP_INCLUDED	include/arrayrep.h	/^#define ARRAYREP_INCLUDED$/;"	d
ARRAY_INCLUDED	include/array.h	/^#define ARRAY_INCLUDED$/;"	d
AS	makefile	/^AS=as$/;"	m
ATOM_INCLUDED	include/atom.h	/^#define ATOM_INCLUDED$/;"	d
Arena_Failed	src/arena.c	/^const Except_T Arena_Failed    =$/;"	v
Arena_NewFailed	src/arena.c	/^const Except_T Arena_NewFailed =$/;"	v
Arena_alloc	src/arena.c	/^void *Arena_alloc(T arena, long nbytes,$/;"	f
Arena_calloc	src/arena.c	/^void *Arena_calloc(T arena, long count, long nbytes,$/;"	f
Arena_dispose	src/arena.c	/^void Arena_dispose(T *ap) {$/;"	f
Arena_free	src/arena.c	/^void Arena_free(T arena) {$/;"	f
Arena_new	src/arena.c	/^T Arena_new(void) {$/;"	f
Arith_ceiling	src/arith.c	/^int Arith_ceiling(int x, int y) {$/;"	f
Arith_div	src/arith.c	/^int Arith_div(int x, int y) {$/;"	f
Arith_floor	src/arith.c	/^int Arith_floor(int x, int y) {$/;"	f
Arith_max	src/arith.c	/^int Arith_max(int x, int y) {$/;"	f
Arith_min	src/arith.c	/^int Arith_min(int x, int y) {$/;"	f
Arith_mod	src/arith.c	/^int Arith_mod(int x, int y) {$/;"	f
ArrayRep_init	src/array.c	/^void ArrayRep_init(T array, int length, int size,$/;"	f
Array_copy	src/array.c	/^T Array_copy(T array, int length) {$/;"	f
Array_free	src/array.c	/^void Array_free(T *array) {$/;"	f
Array_get	src/array.c	/^void *Array_get(T array, int i) {$/;"	f
Array_length	src/array.c	/^int Array_length(T array) {$/;"	f
Array_new	src/array.c	/^T Array_new(int length, int size) {$/;"	f
Array_put	src/array.c	/^void *Array_put(T array, int i, void *elem) {$/;"	f
Array_resize	src/array.c	/^void Array_resize(T array, int length) {$/;"	f
Array_size	src/array.c	/^int Array_size(T array) {$/;"	f
Assert_Failed	src/assert.c	/^const Except_T Assert_Failed = { "Assertion failed" };$/;"	v
Atom_int	src/atom.c	/^const char *Atom_int(long n) {$/;"	f
Atom_length	src/atom.c	/^int Atom_length(const char *str) {$/;"	f
Atom_new	src/atom.c	/^const char *Atom_new(const char *str, int len) {$/;"	f
Atom_string	src/atom.c	/^const char *Atom_string(const char *str) {$/;"	f
B	makefile	/^B=$(BUILDDIR)\/$/;"	m
BASE	src/mp.c	/^#define BASE /;"	d	file:
BASE	src/xp.c	/^#define BASE /;"	d	file:
BIT_INCLUDED	include/bit.h	/^#define BIT_INCLUDED$/;"	d
BPW	src/bit.c	/^#define BPW /;"	d	file:
Bit_clear	src/bit.c	/^void Bit_clear(T set, int lo, int hi) {$/;"	f
Bit_count	src/bit.c	/^int Bit_count(T set) {$/;"	f
Bit_diff	src/bit.c	/^T Bit_diff(T s, T t) {$/;"	f
Bit_eq	src/bit.c	/^int Bit_eq(T s, T t) {$/;"	f
Bit_free	src/bit.c	/^void Bit_free(T *set) {$/;"	f
Bit_get	src/bit.c	/^int Bit_get(T set, int n) {$/;"	f
Bit_inter	src/bit.c	/^T Bit_inter(T s, T t) {$/;"	f
Bit_length	src/bit.c	/^int Bit_length(T set) {$/;"	f
Bit_leq	src/bit.c	/^int Bit_leq(T s, T t) {$/;"	f
Bit_lt	src/bit.c	/^int Bit_lt(T s, T t) {$/;"	f
Bit_map	src/bit.c	/^void Bit_map(T set,$/;"	f
Bit_minus	src/bit.c	/^T Bit_minus(T s, T t) {$/;"	f
Bit_new	src/bit.c	/^T Bit_new(int length) {$/;"	f
Bit_not	src/bit.c	/^void Bit_not(T set, int lo, int hi) {$/;"	f
Bit_put	src/bit.c	/^int Bit_put(T set, int n, int bit) {$/;"	f
Bit_set	src/bit.c	/^void Bit_set(T set, int lo, int hi) {$/;"	f
Bit_union	src/bit.c	/^T Bit_union(T s, T t) {$/;"	f
CALLOC	include/mem.h	/^#define CALLOC(/;"	d
CC	makefile	/^CC=cc$/;"	m
CFLAGS	makefile	/^CFLAGS=-g -I$I$/;"	m
CHAN_INCLUDED	include/chan.h	/^#define CHAN_INCLUDED$/;"	d
CUSTOM	makefile	/^CUSTOM=custom.mk$/;"	m
Chan_new	src/chan.c	/^T Chan_new(void) {$/;"	f
Chan_receive	src/chan.c	/^int Chan_receive(Chan_T c, void *ptr, int size) {$/;"	f
Chan_send	src/chan.c	/^int Chan_send(Chan_T c, const void *ptr, int size) {$/;"	f
DIFF	makefile	/^DIFF=diff$/;"	m
E	makefile	/^E=$/;"	m
ELSE	include/except.h	/^#define ELSE /;"	d
END_LOCK	include/sem.h	/^#define END_LOCK /;"	d
END_TRY	include/except.h	/^#define END_TRY /;"	d
ENTERCRITICAL	src/thread-nt.c	/^#define ENTERCRITICAL /;"	d	file:
EXAMPLES	makefile	/^EXAMPLES=	$Bdouble$E \\$/;"	m
EXCEPT	include/except.h	/^#define EXCEPT(/;"	d
EXCEPT_INCLUDED	include/except.h	/^#define EXCEPT_INCLUDED$/;"	d
EXTRAS	makefile	/^EXTRAS=$(BUILDDIR)\/memcmp$O $(BUILDDIR)\/memmove$O $(BUILDDIR)\/strncmp$O$/;"	m
Except_Frame	include/except.h	/^struct Except_Frame {$/;"	s
Except_Frame	include/except.h	/^typedef struct Except_Frame Except_Frame;$/;"	t	typeref:struct:Except_Frame
Except_entered	include/except.h	/^enum { Except_entered=0, Except_raised,$/;"	e	enum:__anon1
Except_finalized	include/except.h	/^       Except_handled,   Except_finalized };$/;"	e	enum:__anon1
Except_handled	include/except.h	/^       Except_handled,   Except_finalized };$/;"	e	enum:__anon1
Except_raise	src/except.c	/^void Except_raise(const T *e, const char *file,$/;"	f
Except_raised	include/except.h	/^enum { Except_entered=0, Except_raised,$/;"	e	enum:__anon1
FINALLY	include/except.h	/^#define FINALLY /;"	d
FMT_INCLUDED	include/fmt.h	/^#define FMT_INCLUDED$/;"	d
FREE	include/mem.h	/^#define FREE(/;"	d
Fmt_Overflow	src/fmt.c	/^const Except_T Fmt_Overflow = { "Formatting Overflow" };$/;"	v
Fmt_flags	src/fmt.c	/^char *Fmt_flags = "-+ 0";$/;"	v
Fmt_fmt	src/fmt.c	/^void Fmt_fmt(int put(int c, void *), void *cl,$/;"	f
Fmt_fprint	src/fmt.c	/^void Fmt_fprint(FILE *stream, const char *fmt, ...) {$/;"	f
Fmt_print	src/fmt.c	/^void Fmt_print(const char *fmt, ...) {$/;"	f
Fmt_putd	src/fmt.c	/^void Fmt_putd(const char *str, int len,$/;"	f
Fmt_puts	src/fmt.c	/^void Fmt_puts(const char *str, int len,$/;"	f
Fmt_register	src/fmt.c	/^T Fmt_register(int code, T newcvt) {$/;"	f
Fmt_sfmt	src/fmt.c	/^int Fmt_sfmt(char *buf, int size, const char *fmt, ...) {$/;"	f
Fmt_string	src/fmt.c	/^char *Fmt_string(const char *fmt, ...) {$/;"	f
Fmt_vfmt	src/fmt.c	/^void Fmt_vfmt(int put(int c, void *cl), void *cl,$/;"	f
Fmt_vsfmt	src/fmt.c	/^int Fmt_vsfmt(char *buf, int size, const char *fmt,$/;"	f
Fmt_vstring	src/fmt.c	/^char *Fmt_vstring(const char *fmt, va_list ap) {$/;"	f
HASH	src/thread-nt.c	/^#define HASH(/;"	d	file:
I	makefile	/^I=include$/;"	m
IDThread	src/thread-nt.c	/^	DWORD IDThread;		\/* Win 32 thread identifier *\/$/;"	m	struct:T	file:
INTEGER_INCLUDED	examples/integer.h	/^#define INTEGER_INCLUDED$/;"	d
Integer_cmp	examples/integer.c	/^int Integer_cmp(T i1, T i2) {$/;"	f
Integer_fmt	examples/integer.c	/^void Integer_fmt(int code, va_list *app,$/;"	f
Integer_get	examples/integer.c	/^int Integer_get(T integer) {$/;"	f
Integer_new	examples/integer.c	/^T Integer_new(int n) {$/;"	f
Integer_put	examples/integer.c	/^int Integer_put(T integer, int n) {$/;"	f
LD	makefile	/^LD=cc$/;"	m
LDFLAGS	makefile	/^LDFLAGS=-g$/;"	m
LEAVECRITICAL	src/thread-nt.c	/^#define LEAVECRITICAL /;"	d	file:
LIST_INCLUDED	include/list.h	/^#define LIST_INCLUDED$/;"	d
LOCK	include/sem.h	/^#define LOCK(/;"	d
List_append	src/list.c	/^T List_append(T list, T tail) {$/;"	f
List_copy	src/list.c	/^T List_copy(T list) {$/;"	f
List_free	src/list.c	/^void List_free(T *list) {$/;"	f
List_length	src/list.c	/^int List_length(T list) {$/;"	f
List_list	src/list.c	/^T List_list(void *x, ...) {$/;"	f
List_map	src/list.c	/^void List_map(T list,$/;"	f
List_pop	src/list.c	/^T List_pop(T list, void **x) {$/;"	f
List_push	src/list.c	/^T List_push(T list, void *x) {$/;"	f
List_reverse	src/list.c	/^T List_reverse(T list) {$/;"	f
List_toArray	src/list.c	/^void **List_toArray(T list, void *end) {$/;"	f
MEM_INCLUDED	include/mem.h	/^#define MEM_INCLUDED$/;"	d
MP_Dividebyzero	src/mp.c	/^const Except_T MP_Dividebyzero = { "Division by zero" };$/;"	v
MP_INCLUDED	include/mp.h	/^#define MP_INCLUDED$/;"	d
MP_Overflow	src/mp.c	/^const Except_T MP_Overflow     = { "Overflow" };$/;"	v
MP_add	src/mp.c	/^T MP_add(T z, T x, T y) {$/;"	f
MP_addi	src/mp.c	/^T MP_addi(T z, T x, long y) {$/;"	f
MP_addu	src/mp.c	/^T MP_addu(T z, T x, T y) {$/;"	f
MP_addui	src/mp.c	/^T MP_addui(T z, T x, unsigned long y) {$/;"	f
MP_and	src/mp.c	/^T MP_and(T z, T x, T y) { bitop(&); }$/;"	f
MP_andi	src/mp.c	/^T MP_andi(T z, T x, unsigned long y) { bitopi(MP_and); }$/;"	f
MP_ashift	src/mp.c	/^T MP_ashift(T z, T x, int s) { shft(sign(x),XP_rshift); }$/;"	f
MP_cmp	src/mp.c	/^int MP_cmp(T x, T y) {$/;"	f
MP_cmpi	src/mp.c	/^int MP_cmpi(T x, long y) {$/;"	f
MP_cmpu	src/mp.c	/^int MP_cmpu(T x, T y) {$/;"	f
MP_cmpui	src/mp.c	/^int MP_cmpui(T x, unsigned long y) {$/;"	f
MP_cvt	src/mp.c	/^T MP_cvt(int m, T z, T x) {$/;"	f
MP_cvtu	src/mp.c	/^T MP_cvtu(int m, T z, T x) {$/;"	f
MP_div	src/mp.c	/^T MP_div(T z, T x, T y) {$/;"	f
MP_divi	src/mp.c	/^T MP_divi(T z, T x, long y) {$/;"	f
MP_divu	src/mp.c	/^T MP_divu(T z, T x, T y) {$/;"	f
MP_divui	src/mp.c	/^T MP_divui(T z, T x, unsigned long y) {$/;"	f
MP_fmt	src/mp.c	/^void MP_fmt(int code, va_list *app,$/;"	f
MP_fmtu	src/mp.c	/^void MP_fmtu(int code, va_list *app,$/;"	f
MP_fromint	src/mp.c	/^T MP_fromint(T z, long v) {$/;"	f
MP_fromintu	src/mp.c	/^T MP_fromintu(T z, unsigned long u) {$/;"	f
MP_fromstr	src/mp.c	/^T MP_fromstr(T z, const char *str, int base, char **end){$/;"	f
MP_lshift	src/mp.c	/^T MP_lshift(T z, T x, int s) { shft(0, XP_lshift); }$/;"	f
MP_mod	src/mp.c	/^T MP_mod(T z, T x, T y) {$/;"	f
MP_modi	src/mp.c	/^long MP_modi(T x, long y) {$/;"	f
MP_modu	src/mp.c	/^T MP_modu(T z, T x, T y) {$/;"	f
MP_modui	src/mp.c	/^unsigned long MP_modui(T x, unsigned long y) {$/;"	f
MP_mul	src/mp.c	/^T MP_mul(T z, T x, T y) {$/;"	f
MP_mul2	src/mp.c	/^T MP_mul2(T z, T x, T y) {$/;"	f
MP_mul2u	src/mp.c	/^T MP_mul2u(T z, T x, T y) {$/;"	f
MP_muli	src/mp.c	/^T MP_muli(T z, T x, long y) {$/;"	f
MP_mulu	src/mp.c	/^T MP_mulu(T z, T x, T y) {$/;"	f
MP_mului	src/mp.c	/^T MP_mului(T z, T x, unsigned long y) {$/;"	f
MP_neg	src/mp.c	/^T MP_neg(T z, T x) {$/;"	f
MP_new	src/mp.c	/^T MP_new(unsigned long u) {$/;"	f
MP_not	src/mp.c	/^T MP_not(T z, T x) {$/;"	f
MP_or	src/mp.c	/^T MP_or (T z, T x, T y) { bitop(|); }$/;"	f
MP_ori	src/mp.c	/^T MP_ori (T z, T x, unsigned long y) { bitopi(MP_or);  }$/;"	f
MP_rshift	src/mp.c	/^T MP_rshift(T z, T x, int s) { shft(0, XP_rshift); }$/;"	f
MP_set	src/mp.c	/^int MP_set(int n) {$/;"	f
MP_sub	src/mp.c	/^T MP_sub(T z, T x, T y) {$/;"	f
MP_subi	src/mp.c	/^T MP_subi(T z, T x, long y) {$/;"	f
MP_subu	src/mp.c	/^T MP_subu(T z, T x, T y) {$/;"	f
MP_subui	src/mp.c	/^T MP_subui(T z, T x, unsigned long y) {$/;"	f
MP_toint	src/mp.c	/^long MP_toint(T x) {$/;"	f
MP_tointu	src/mp.c	/^unsigned long MP_tointu(T x) {$/;"	f
MP_tostr	src/mp.c	/^char *MP_tostr(char *str, int size, int base, T x) {$/;"	f
MP_xor	src/mp.c	/^T MP_xor(T z, T x, T y) { bitop(^); }$/;"	f
MP_xori	src/mp.c	/^T MP_xori(T z, T x, unsigned long y) { bitopi(MP_xor); }$/;"	f
Mem_Failed	src/mem.c	/^const Except_T Mem_Failed = { "Allocation Failed" };$/;"	v
Mem_Failed	src/memchk.c	/^const Except_T Mem_Failed = { "Allocation Failed" };$/;"	v
Mem_alloc	src/mem.c	/^void *Mem_alloc(long nbytes, const char *file, int line){$/;"	f
Mem_alloc	src/memchk.c	/^void *Mem_alloc(long nbytes, const char *file, int line){$/;"	f
Mem_calloc	src/mem.c	/^void *Mem_calloc(long count, long nbytes,$/;"	f
Mem_calloc	src/memchk.c	/^void *Mem_calloc(long count, long nbytes,$/;"	f
Mem_free	src/mem.c	/^void Mem_free(void *ptr, const char *file, int line) {$/;"	f
Mem_free	src/memchk.c	/^void Mem_free(void *ptr, const char *file, int line) {$/;"	f
Mem_resize	src/mem.c	/^void *Mem_resize(void *ptr, long nbytes,$/;"	f
Mem_resize	src/memchk.c	/^void *Mem_resize(void *ptr, long nbytes,$/;"	f
NALLOC	src/memchk.c	/^#define NALLOC /;"	d	file:
NBUMP	examples/spin.c	/^#define NBUMP /;"	d	file:
NDESCRIPTORS	src/memchk.c	/^#define NDESCRIPTORS /;"	d	file:
NELEMS	src/atom.c	/^#define NELEMS(/;"	d	file:
NEW	include/mem.h	/^#define  NEW(/;"	d
NEW0	include/mem.h	/^#define NEW0(/;"	d
O	makefile	/^O=.o$/;"	m
OBJS	makefile	/^OBJS=	$Bap$O \\$/;"	m
RAISE	include/except.h	/^#define RAISE(/;"	d
RANLIB	makefile	/^RANLIB=ranlib$/;"	m
RERAISE	include/except.h	/^#define RERAISE /;"	d
RESIZE	include/mem.h	/^#define RESIZE(/;"	d
RETURN	include/except.h	/^#define RETURN /;"	d
RING_INCLUDED	include/ring.h	/^#define RING_INCLUDED$/;"	d
RM	makefile	/^RM=rm -f$/;"	m
Ring_add	src/ring.c	/^void *Ring_add(T ring, int pos, void *x) {$/;"	f
Ring_addhi	src/ring.c	/^void *Ring_addhi(T ring, void *x) {$/;"	f
Ring_addlo	src/ring.c	/^void *Ring_addlo(T ring, void *x) {$/;"	f
Ring_free	src/ring.c	/^void Ring_free(T *ring) {$/;"	f
Ring_get	src/ring.c	/^void *Ring_get(T ring, int i) {$/;"	f
Ring_length	src/ring.c	/^int Ring_length(T ring) {$/;"	f
Ring_new	src/ring.c	/^T Ring_new(void) {$/;"	f
Ring_put	src/ring.c	/^void *Ring_put(T ring, int i, void *x) {$/;"	f
Ring_remhi	src/ring.c	/^void *Ring_remhi(T ring) {$/;"	f
Ring_remlo	src/ring.c	/^void *Ring_remlo(T ring) {$/;"	f
Ring_remove	src/ring.c	/^void *Ring_remove(T ring, int i) {$/;"	f
Ring_ring	src/ring.c	/^T Ring_ring(void *x, ...) {$/;"	f
Ring_rotate	src/ring.c	/^void Ring_rotate(T ring, int n) {$/;"	f
SEM_INCLUDED	include/sem.h	/^#define SEM_INCLUDED$/;"	d
SEQ_INCLUDED	include/seq.h	/^#define SEQ_INCLUDED$/;"	d
SET_INCLUDED	include/set.h	/^#define SET_INCLUDED$/;"	d
STACK_INCLUDED	include/stack.h	/^#define STACK_INCLUDED$/;"	d
STR_INCLUDED	include/str.h	/^#define STR_INCLUDED$/;"	d
Sem_init	src/thread-nt.c	/^void Sem_init(T *s, int count) {$/;"	f
Sem_init	src/thread.c	/^void Sem_init(T *s, int count) {$/;"	f
Sem_new	src/thread-nt.c	/^T *Sem_new(int count) {$/;"	f
Sem_new	src/thread.c	/^T *Sem_new(int count) {$/;"	f
Sem_signal	src/thread-nt.c	/^void Sem_signal(T *s) {$/;"	f
Sem_signal	src/thread.c	/^void Sem_signal(T *s) {$/;"	f
Sem_wait	src/thread-nt.c	/^void Sem_wait(T *s) {$/;"	f
Sem_wait	src/thread.c	/^void Sem_wait(T *s) {$/;"	f
Seq_addhi	src/seq.c	/^void *Seq_addhi(T seq, void *x) {$/;"	f
Seq_addlo	src/seq.c	/^void *Seq_addlo(T seq, void *x) {$/;"	f
Seq_free	src/seq.c	/^void Seq_free(T *seq) {$/;"	f
Seq_get	src/seq.c	/^void *Seq_get(T seq, int i) {$/;"	f
Seq_length	src/seq.c	/^int Seq_length(T seq) {$/;"	f
Seq_new	src/seq.c	/^T Seq_new(int hint) {$/;"	f
Seq_put	src/seq.c	/^void *Seq_put(T seq, int i, void *x) {$/;"	f
Seq_remhi	src/seq.c	/^void *Seq_remhi(T seq) {$/;"	f
Seq_remlo	src/seq.c	/^void *Seq_remlo(T seq) {$/;"	f
Seq_seq	src/seq.c	/^T Seq_seq(void *x, ...) {$/;"	f
Set_diff	src/set.c	/^T Set_diff(T s, T t) {$/;"	f
Set_free	src/set.c	/^void Set_free(T *set) {$/;"	f
Set_inter	src/set.c	/^T Set_inter(T s, T t) {$/;"	f
Set_length	src/set.c	/^int Set_length(T set) {$/;"	f
Set_map	src/set.c	/^void Set_map(T set,$/;"	f
Set_member	src/set.c	/^int Set_member(T set, const void *member) {$/;"	f
Set_minus	src/set.c	/^T Set_minus(T t, T s) {$/;"	f
Set_new	src/set.c	/^T Set_new(int hint,$/;"	f
Set_put	src/set.c	/^void Set_put(T set, const void *member) {$/;"	f
Set_remove	src/set.c	/^void *Set_remove(T set, const void *member) {$/;"	f
Set_toArray	src/set.c	/^void **Set_toArray(T set, void *end) {$/;"	f
Set_union	src/set.c	/^T Set_union(T s, T t) {$/;"	f
Stack_empty	src/stack.c	/^int Stack_empty(T stk) {$/;"	f
Stack_free	src/stack.c	/^void Stack_free(T *stk) {$/;"	f
Stack_new	src/stack.c	/^T Stack_new(void) {$/;"	f
Stack_pop	src/stack.c	/^void *Stack_pop(T stk) {$/;"	f
Stack_push	src/stack.c	/^void Stack_push(T stk, void *x) {$/;"	f
Str_any	src/str.c	/^int Str_any(const char *s, int i, const char *set) {$/;"	f
Str_cat	src/str.c	/^char *Str_cat(const char *s1, int i1, int j1,$/;"	f
Str_catv	src/str.c	/^char *Str_catv(const char *s, ...) {$/;"	f
Str_chr	src/str.c	/^int Str_chr(const char *s, int i, int j, int c) {$/;"	f
Str_cmp	src/str.c	/^int Str_cmp(const char *s1, int i1, int j1,$/;"	f
Str_dup	src/str.c	/^char *Str_dup(const char *s, int i, int j, int n) {$/;"	f
Str_find	src/str.c	/^int Str_find(const char *s, int i, int j,$/;"	f
Str_fmt	src/str.c	/^void Str_fmt(int code, va_list *app,$/;"	f
Str_len	src/str.c	/^int Str_len(const char *s, int i, int j) {$/;"	f
Str_many	src/str.c	/^int Str_many(const char *s, int i, int j,$/;"	f
Str_map	src/str.c	/^char *Str_map(const char *s, int i, int j,$/;"	f
Str_match	src/str.c	/^int Str_match(const char *s, int i, int j,$/;"	f
Str_pos	src/str.c	/^int Str_pos(const char *s, int i) {$/;"	f
Str_rchr	src/str.c	/^int Str_rchr(const char *s, int i, int j, int c) {$/;"	f
Str_reverse	src/str.c	/^char *Str_reverse(const char *s, int i, int j) {$/;"	f
Str_rfind	src/str.c	/^int Str_rfind(const char *s, int i, int j,$/;"	f
Str_rmany	src/str.c	/^int Str_rmany(const char *s, int i, int j,$/;"	f
Str_rmatch	src/str.c	/^int Str_rmatch(const char *s, int i, int j,$/;"	f
Str_rupto	src/str.c	/^int Str_rupto(const char *s, int i, int j,$/;"	f
Str_sub	src/str.c	/^char *Str_sub(const char *s, int i, int j) {$/;"	f
Str_upto	src/str.c	/^int Str_upto(const char *s, int i, int j,$/;"	f
T	examples/integer.c	/^#define T /;"	d	file:
T	examples/integer.c	/^typedef int *T;$/;"	t	file:
T	examples/integer.h	/^#define T /;"	d
T	examples/integer.h	/^#undef T$/;"	d
T	examples/integer.h	/^typedef int *T;$/;"	t
T	include/ap.h	/^#define T /;"	d
T	include/ap.h	/^#undef T$/;"	d
T	include/ap.h	/^typedef struct T *T;$/;"	t	typeref:struct:T
T	include/arena.h	/^#define T /;"	d
T	include/arena.h	/^#undef T$/;"	d
T	include/arena.h	/^typedef struct T *T;$/;"	t	typeref:struct:T
T	include/array.h	/^#define T /;"	d
T	include/array.h	/^#undef T$/;"	d
T	include/array.h	/^typedef struct T *T;$/;"	t	typeref:struct:T
T	include/arrayrep.h	/^#define T /;"	d
T	include/arrayrep.h	/^#undef T$/;"	d
T	include/arrayrep.h	/^struct T {$/;"	s
T	include/bit.h	/^#define T /;"	d
T	include/bit.h	/^#undef T$/;"	d
T	include/bit.h	/^typedef struct T *T;$/;"	t	typeref:struct:T
T	include/chan.h	/^#define T /;"	d
T	include/chan.h	/^#undef T$/;"	d
T	include/chan.h	/^typedef struct T *T;$/;"	t	typeref:struct:T
T	include/except.h	/^#define T /;"	d
T	include/except.h	/^#undef T$/;"	d
T	include/except.h	/^typedef struct T {$/;"	s
T	include/except.h	/^} T;$/;"	t	typeref:struct:T
T	include/fmt.h	/^#define T /;"	d
T	include/fmt.h	/^#undef T$/;"	d
T	include/fmt.h	/^typedef void (*T)(int code, va_list *app,$/;"	t
T	include/list.h	/^#define T /;"	d
T	include/list.h	/^#undef T$/;"	d
T	include/list.h	/^struct T {$/;"	s
T	include/list.h	/^typedef struct T *T;$/;"	t	typeref:struct:T
T	include/mp.h	/^#define T /;"	d
T	include/mp.h	/^#undef T$/;"	d
T	include/mp.h	/^typedef unsigned char *T;$/;"	t
T	include/ring.h	/^#define T /;"	d
T	include/ring.h	/^#undef T$/;"	d
T	include/ring.h	/^typedef struct T *T;$/;"	t	typeref:struct:T
T	include/sem.h	/^#define T /;"	d
T	include/sem.h	/^#undef T$/;"	d
T	include/sem.h	/^typedef struct T {$/;"	s
T	include/sem.h	/^} T;$/;"	t	typeref:struct:T
T	include/seq.h	/^#define T /;"	d
T	include/seq.h	/^#undef T$/;"	d
T	include/seq.h	/^typedef struct T *T;$/;"	t	typeref:struct:T
T	include/set.h	/^#define T /;"	d
T	include/set.h	/^#undef T$/;"	d
T	include/set.h	/^typedef struct T *T;$/;"	t	typeref:struct:T
T	include/stack.h	/^#define T /;"	d
T	include/stack.h	/^#undef T$/;"	d
T	include/stack.h	/^typedef struct T *T;$/;"	t	typeref:struct:T
T	include/str.h	/^#undef T$/;"	d
T	include/table.h	/^#define T /;"	d
T	include/table.h	/^#undef T$/;"	d
T	include/table.h	/^typedef struct T *T;$/;"	t	typeref:struct:T
T	include/text.h	/^#define T /;"	d
T	include/text.h	/^#undef T$/;"	d
T	include/text.h	/^typedef struct T {$/;"	s
T	include/text.h	/^} T;$/;"	t	typeref:struct:T
T	include/thread.h	/^#define T /;"	d
T	include/thread.h	/^#undef T$/;"	d
T	include/thread.h	/^typedef struct T *T;$/;"	t	typeref:struct:T
T	include/xp.h	/^#define T /;"	d
T	include/xp.h	/^#undef T$/;"	d
T	include/xp.h	/^typedef unsigned char *T;$/;"	t
T	src/ap.c	/^#define T /;"	d	file:
T	src/ap.c	/^struct T {$/;"	s	file:
T	src/arena.c	/^#define T /;"	d	file:
T	src/arena.c	/^struct T {$/;"	s	file:
T	src/array.c	/^#define T /;"	d	file:
T	src/bit.c	/^#define T /;"	d	file:
T	src/bit.c	/^struct T {$/;"	s	file:
T	src/chan.c	/^#define T /;"	d	file:
T	src/chan.c	/^struct T {$/;"	s	file:
T	src/except.c	/^#define T /;"	d	file:
T	src/fmt.c	/^#define T /;"	d	file:
T	src/list.c	/^#define T /;"	d	file:
T	src/mp.c	/^#define T /;"	d	file:
T	src/ring.c	/^#define T /;"	d	file:
T	src/ring.c	/^struct T {$/;"	s	file:
T	src/seq.c	/^#define T /;"	d	file:
T	src/seq.c	/^struct T {$/;"	s	file:
T	src/set.c	/^#define T /;"	d	file:
T	src/set.c	/^struct T {$/;"	s	file:
T	src/stack.c	/^#define T /;"	d	file:
T	src/stack.c	/^struct T {$/;"	s	file:
T	src/table.c	/^#define T /;"	d	file:
T	src/table.c	/^struct T {$/;"	s	file:
T	src/text.c	/^#define T /;"	d	file:
T	src/thread-nt.c	/^#define T /;"	d	file:
T	src/thread-nt.c	/^#undef T$/;"	d	file:
T	src/thread-nt.c	/^struct T {$/;"	s	file:
T	src/thread.c	/^#define T /;"	d	file:
T	src/thread.c	/^#undef T$/;"	d	file:
T	src/thread.c	/^struct T {$/;"	s	file:
T	src/xp.c	/^#define T /;"	d	file:
TABLE_INCLUDED	include/table.h	/^#define TABLE_INCLUDED$/;"	d
TEXT_INCLUDED	include/text.h	/^#define TEXT_INCLUDED$/;"	d
THREADS	makefile	/^THREADS=$(BUILDDIR)\/thread$O $(BUILDDIR)\/swtch$O$/;"	m
THREAD_INCLUDED	include/thread.h	/^#define THREAD_INCLUDED$/;"	d
THRESHOLD	src/arena.c	/^#define THRESHOLD /;"	d	file:
TRY	include/except.h	/^#define TRY /;"	d
Table_free	src/table.c	/^void Table_free(T *table) {$/;"	f
Table_get	src/table.c	/^void *Table_get(T table, const void *key) {$/;"	f
Table_length	src/table.c	/^int Table_length(T table) {$/;"	f
Table_map	src/table.c	/^void Table_map(T table,$/;"	f
Table_new	src/table.c	/^T Table_new(int hint,$/;"	f
Table_put	src/table.c	/^void *Table_put(T table, const void *key, void *value) {$/;"	f
Table_remove	src/table.c	/^void *Table_remove(T table, const void *key) {$/;"	f
Table_toArray	src/table.c	/^void **Table_toArray(T table, void *end) {$/;"	f
Text_any	src/text.c	/^int Text_any(T s, int i, T set) {$/;"	f
Text_ascii	src/text.c	/^const T Text_ascii  = { 127, cset };$/;"	v
Text_box	src/text.c	/^T Text_box(const char *str, int len) {$/;"	f
Text_cat	src/text.c	/^T Text_cat(T s1, T s2) {$/;"	f
Text_chr	src/text.c	/^int Text_chr(T s, int i, int j, int c) {$/;"	f
Text_cmp	src/text.c	/^int Text_cmp(T s1, T s2) {$/;"	f
Text_cset	src/text.c	/^const T Text_cset   = { 256, cset };$/;"	v
Text_digits	src/text.c	/^const T Text_digits = {  10, cset + '0' };$/;"	v
Text_dup	src/text.c	/^T Text_dup(T s, int n) {$/;"	f
Text_find	src/text.c	/^int Text_find(T s, int i, int j, T str) {$/;"	f
Text_fmt	src/text.c	/^void Text_fmt(int code, va_list *app,$/;"	f
Text_get	src/text.c	/^char *Text_get(char *str, int size, T s) {$/;"	f
Text_lcase	src/text.c	/^const T Text_lcase  = {  26, cset + 'a' };$/;"	v
Text_many	src/text.c	/^int Text_many(T s, int i, int j, T set) {$/;"	f
Text_map	src/text.c	/^T Text_map(T s, const T *from, const T *to) {$/;"	f
Text_match	src/text.c	/^int Text_match(T s, int i, int j, T str) {$/;"	f
Text_null	src/text.c	/^const T Text_null   = {   0, cset };$/;"	v
Text_pos	src/text.c	/^int Text_pos(T s, int i) {$/;"	f
Text_put	src/text.c	/^T Text_put(const char *str) {$/;"	f
Text_rchr	src/text.c	/^int Text_rchr(T s, int i, int j, int c) {$/;"	f
Text_restore	src/text.c	/^void Text_restore(Text_save_T *save) {$/;"	f
Text_reverse	src/text.c	/^T Text_reverse(T s) {$/;"	f
Text_rfind	src/text.c	/^int Text_rfind(T s, int i, int j, T str) {$/;"	f
Text_rmany	src/text.c	/^int Text_rmany(T s, int i, int j, T set) {$/;"	f
Text_rmatch	src/text.c	/^int Text_rmatch(T s, int i, int j, T str) {$/;"	f
Text_rupto	src/text.c	/^int Text_rupto(T s, int i, int j, T set) {$/;"	f
Text_save	src/text.c	/^Text_save_T Text_save(void) {$/;"	f
Text_save_T	include/text.h	/^typedef struct Text_save_T *Text_save_T;$/;"	t	typeref:struct:Text_save_T
Text_save_T	src/text.c	/^struct Text_save_T {$/;"	s	file:
Text_sub	src/text.c	/^T Text_sub(T s, int i, int j) {$/;"	f
Text_ucase	src/text.c	/^const T Text_ucase  = {  26, cset + 'A' };$/;"	v
Text_upto	src/text.c	/^int Text_upto(T s, int i, int j, T set) {$/;"	f
Thread_Alerted	src/thread-nt.c	/^const Except_T Thread_Alerted = { "Thread alerted" };$/;"	v
Thread_Alerted	src/thread.c	/^const Except_T Thread_Alerted = { "Thread alerted" };$/;"	v
Thread_Failed	src/thread-nt.c	/^const Except_T Thread_Failed  = { "Thread creation failed" };$/;"	v
Thread_Failed	src/thread.c	/^const Except_T Thread_Failed =$/;"	v
Thread_alert	src/thread-nt.c	/^void Thread_alert(T t) {$/;"	f
Thread_alert	src/thread.c	/^void Thread_alert(T t) {$/;"	f
Thread_exit	src/thread-nt.c	/^void Thread_exit(int code) {$/;"	f
Thread_exit	src/thread.c	/^void Thread_exit(int code) {$/;"	f
Thread_init	src/thread-nt.c	/^int Thread_init(int preempt, ...) {$/;"	f
Thread_init	src/thread.c	/^int Thread_init(int preempt, ...) {$/;"	f
Thread_join	src/thread-nt.c	/^int Thread_join(T t) {$/;"	f
Thread_join	src/thread.c	/^int Thread_join(T t) {$/;"	f
Thread_new	src/thread-nt.c	/^T Thread_new(int apply(void *), void *args, int nbytes, ...) {$/;"	f
Thread_new	src/thread.c	/^T Thread_new(int apply(void *), void *args,$/;"	f
Thread_pause	src/thread-nt.c	/^void Thread_pause(void) {$/;"	f
Thread_pause	src/thread.c	/^void Thread_pause(void) {$/;"	f
Thread_self	src/thread-nt.c	/^T Thread_self(void) {$/;"	f
Thread_self	src/thread.c	/^T Thread_self(void) {$/;"	f
Unsupported	src/swtch.s	/^Unsupported platform$/;"	l
XP_INCLUDED	include/xp.h	/^#define XP_INCLUDED$/;"	d
XP_add	src/xp.c	/^int XP_add(int n, T z, T x, T y, int carry) {$/;"	f
XP_cmp	src/xp.c	/^int XP_cmp(int n, T x, T y) {$/;"	f
XP_diff	src/xp.c	/^int XP_diff(int n, T z, T x, int y) {$/;"	f
XP_div	src/xp.c	/^int XP_div(int n, T q, T x, int m, T y, T r, T tmp) {$/;"	f
XP_fromint	src/xp.c	/^unsigned long XP_fromint(int n, T z, unsigned long u) {$/;"	f
XP_fromstr	src/xp.c	/^int XP_fromstr(int n, T z, const char *str,$/;"	f
XP_length	src/xp.c	/^int XP_length(int n, T x) {$/;"	f
XP_lshift	src/xp.c	/^void XP_lshift(int n, T z, int m, T x, int s, int fill) {$/;"	f
XP_mul	src/xp.c	/^int XP_mul(T z, int n, T x, int m, T y) {$/;"	f
XP_neg	src/xp.c	/^int XP_neg(int n, T z, T x, int carry) {$/;"	f
XP_product	src/xp.c	/^int XP_product(int n, T z, T x, int y) {$/;"	f
XP_quotient	src/xp.c	/^int XP_quotient(int n, T z, T x, int y) {$/;"	f
XP_rshift	src/xp.c	/^void XP_rshift(int n, T z, int m, T x, int s, int fill) {$/;"	f
XP_sub	src/xp.c	/^int XP_sub(int n, T z, T x, T y, int borrow) {$/;"	f
XP_sum	src/xp.c	/^int XP_sum(int n, T z, T x, int y) {$/;"	f
XP_toint	src/xp.c	/^unsigned long XP_toint(int n, T x) {$/;"	f
XP_tostr	src/xp.c	/^char *XP_tostr(char *str, int size, int base,$/;"	f
_ENDMONITOR	src/swtch.s	/^_ENDMONITOR:$/;"	l
_MONITOR	src/thread.c	/^void _MONITOR(void) {}$/;"	f
__ENDMONITOR	src/swtch.s	/^	__ENDMONITOR:$/;"	l
__ENDMONITOR	src/swtch.s	/^__ENDMONITOR:$/;"	l
__start	src/swtch.s	/^	__start:	ld	[%sp+64+4],%o0$/;"	l
__swtch	src/swtch.s	/^	__swtch:	save	%sp,-(8+64),%sp$/;"	l
__swtch	src/swtch.s	/^__swtch:$/;"	l
__thrstart	src/swtch.s	/^__thrstart:$/;"	l
_start	src/swtch.s	/^_start:	.frame	$sp,0,$26$/;"	l
_start	src/swtch.s	/^_start:	move	$4,$23	# register 23 holds args$/;"	l
_swtch	src/swtch.s	/^_swtch:	.frame	$sp,88,$31$/;"	l
_swtch	src/swtch.s	/^_swtch:	lda	$sp,-112($sp)	# allocate _swtch's frame$/;"	l
_swtch	src/swtch.s	/^_swtch:$/;"	l
_thrstart	src/swtch.s	/^_thrstart:$/;"	l
a	examples/sort.c	/^	int *a;$/;"	m	struct:args	file:
a	src/arena.c	/^	union align a;$/;"	m	union:header	typeref:union:header::align	file:
add	examples/mpcalc.c	/^	MP_T (*add)(MP_T, MP_T, MP_T);$/;"	m	struct:__anon2	file:
add	src/ap.c	/^static T add(T z, T x, T y) {$/;"	f	file:
addThread	src/thread-nt.c	/^static void addThread(T t) {$/;"	f	file:
alerted	src/thread-nt.c	/^	int alerted;		\/* 1 if this thread has been alerted *\/$/;"	m	struct:T	file:
alerted	src/thread.c	/^	int alerted;$/;"	m	struct:T	file:
align	src/arena.c	/^union align {$/;"	u	file:
align	src/memchk.c	/^union align {$/;"	u	file:
alloc	src/text.c	/^static char *alloc(int len) {$/;"	f	file:
allthreads	src/thread-nt.c	/^static T allthreads[317];$/;"	v	file:
append	src/fmt.c	/^static int append(int c, void *cl) {$/;"	f	file:
apply	src/thread-nt.c	/^	int (*apply)(void *);	\/* initial function for this thread *\/$/;"	m	struct:T	file:
args	examples/sieve.c	/^struct args {$/;"	s	file:
args	examples/sort.c	/^struct args {$/;"	s	file:
args	examples/spin.c	/^struct args {$/;"	s	file:
args	src/thread-nt.c	/^	void *args;		\/* argument for apply *\/$/;"	m	struct:T	file:
array	include/arrayrep.h	/^	char *array;$/;"	m	struct:T
array	src/seq.c	/^	struct Array_T array;$/;"	m	struct:T	typeref:struct:T::Array_T	file:
assert	include/assert.h	/^#define assert(/;"	d
assert	include/assert.h	/^#undef assert$/;"	d
assert	src/assert.c	/^void (assert)(int e) {$/;"	f
atom	src/atom.c	/^static struct atom {$/;"	s	file:
avail	src/arena.c	/^	char *avail;$/;"	m	struct:T	file:
avail	src/text.c	/^	char *avail;$/;"	m	struct:Text_save_T	file:
avail	src/text.c	/^	char *avail;$/;"	m	struct:chunk	file:
b	src/arena.c	/^	struct T b;$/;"	m	union:header	typeref:struct:header::T	file:
basename	examples/basename.c	/^char *basename(char *path, int i, int j, char *suffix) {$/;"	f
binding	src/table.c	/^	struct binding {$/;"	s	struct:T	file:
bitop	src/mp.c	/^#define bitop(/;"	d	file:
bitopi	src/mp.c	/^#define bitopi(/;"	d	file:
bp	src/fmt.c	/^	char *bp;$/;"	m	struct:buf	file:
buckets	src/atom.c	/^} *buckets[2048];$/;"	v	typeref:struct:atom	file:
buckets	src/set.c	/^	} **buckets;$/;"	m	struct:T	typeref:struct:T::member	file:
buckets	src/table.c	/^	} **buckets;$/;"	m	struct:T	typeref:struct:T::binding	file:
buf	src/fmt.c	/^	char *buf;$/;"	m	struct:buf	file:
buf	src/fmt.c	/^struct buf {$/;"	s	file:
bugs	install.html	/^<H2><A NAME="bugs">Reporting Bugs<\/A><\/H2>$/;"	a
bytes	src/bit.c	/^	unsigned char *bytes;$/;"	m	struct:T	file:
c	examples/sieve.c	/^	Chan_T c;$/;"	m	struct:args	file:
chunk	src/text.c	/^static struct chunk {$/;"	s	file:
cmp	src/ap.c	/^static int cmp(T x, T y) {$/;"	f	file:
cmp	src/set.c	/^	int (*cmp)(const void *x, const void *y);$/;"	m	struct:T	file:
cmp	src/table.c	/^	int (*cmp)(const void *x, const void *y);$/;"	m	struct:T	file:
cmpatom	src/set.c	/^static int cmpatom(const void *x, const void *y) {$/;"	f	file:
cmpatom	src/table.c	/^static int cmpatom(const void *x, const void *y) {$/;"	f	file:
cmpint	examples/xref.c	/^int cmpint(const void *x, const void *y) {$/;"	f
code	src/thread-nt.c	/^	int code;		\/* exit code *\/$/;"	m	struct:T	file:
code	src/thread.c	/^	int code;$/;"	m	struct:T	file:
compare	examples/cref.c	/^int compare(const void *x, const void *y) {$/;"	f
compare	examples/iref.c	/^int compare(const void *x, const void *y) {$/;"	f
compare	examples/kref.c	/^int compare(const void *x, const void *y) {$/;"	f
compare	examples/wf.c	/^int compare(const void *x, const void *y) {$/;"	f
compare	examples/xref.c	/^int compare(const void *x, const void *y) {$/;"	f
convert	src/str.c	/^#define convert(/;"	d	file:
copy	examples/cref.c	/^Text_T *copy(Text_T t) {$/;"	f
copy	examples/iref.c	/^Text_T *copy(Text_T t) {$/;"	f
copy	src/bit.c	/^static T copy(T t) {$/;"	f	file:
copy	src/set.c	/^static T copy(T t, int hint) {$/;"	f	file:
count	include/sem.h	/^	int count;$/;"	m	struct:T
count	src/stack.c	/^	int count;$/;"	m	struct:T	file:
cref	examples/cref.c	/^void cref(char *name, FILE *fp, Table_T identifiers) {$/;"	f
critical	src/thread-nt.c	/^static int critical;$/;"	v	file:
critical	src/thread.c	/^static int critical;$/;"	v	file:
csection	src/thread-nt.c	/^static CRITICAL_SECTION csection;$/;"	v	file:
cset	src/text.c	/^static char cset[] =$/;"	v	file:
current	src/text.c	/^	struct chunk *current;$/;"	m	struct:Text_save_T	typeref:struct:Text_save_T::chunk	file:
current	src/text.c	/^} head = { NULL, NULL, NULL }, *current = &head;$/;"	v	typeref:struct:chunk	file:
current	src/thread.c	/^static T current;$/;"	v	file:
cutoff	examples/sort.c	/^int cutoff = 10000;$/;"	v
cvt	src/fmt.c	/^static T cvt[256] = {$/;"	v	file:
cvt_c	src/fmt.c	/^static void cvt_c(int code, va_list *app,$/;"	f	file:
cvt_d	src/fmt.c	/^static void cvt_d(int code, va_list *app,$/;"	f	file:
cvt_f	src/fmt.c	/^static void cvt_f(int code, va_list *app,$/;"	f	file:
cvt_o	src/fmt.c	/^static void cvt_o(int code, va_list *app,$/;"	f	file:
cvt_p	src/fmt.c	/^static void cvt_p(int code, va_list *app,$/;"	f	file:
cvt_s	src/fmt.c	/^static void cvt_s(int code, va_list *app,$/;"	f	file:
cvt_u	src/fmt.c	/^static void cvt_u(int code, va_list *app,$/;"	f	file:
cvt_x	src/fmt.c	/^static void cvt_x(int code, va_list *app,$/;"	f	file:
dalloc	src/memchk.c	/^static struct descriptor *dalloc(void *ptr, long size,$/;"	f	file:
delete	src/thread.c	/^static void delete(T t, T *q) {$/;"	f	file:
descriptor	src/memchk.c	/^static struct descriptor {$/;"	s	file:
digits	src/ap.c	/^	XP_T digits;$/;"	m	struct:T	file:
dirname	examples/basename.c	/^char *dirname(char *path, int i, int j) {$/;"	f
div	examples/mpcalc.c	/^	MP_T (*div)(MP_T, MP_T, MP_T);$/;"	m	struct:__anon2	file:
doubleword	examples/double.c	/^void doubleword(char *name, FILE *fp) {$/;"	f
elem	src/stack.c	/^	struct elem {$/;"	s	struct:T	file:
env	include/except.h	/^	jmp_buf env;$/;"	m	struct:Except_Frame
equal	src/text.c	/^#define equal(/;"	d	file:
estack	src/thread.c	/^	Except_Frame *estack;$/;"	m	struct:T	file:
exception	include/except.h	/^	const T *exception;$/;"	m	struct:Except_Frame
expand	src/seq.c	/^static void expand(T seq) {$/;"	f	file:
f	examples/mpcalc.c	/^ *f = &s;$/;"	v	typeref:struct:__anon2
file	include/except.h	/^	const char *file;$/;"	m	struct:Except_Frame
file	src/memchk.c	/^	const char *file;$/;"	m	struct:descriptor	file:
filter	examples/sieve.c	/^void filter(int primes[], Chan_T input, Chan_T output) {$/;"	f
find	src/memchk.c	/^static struct descriptor *find(const void *ptr) {$/;"	f	file:
first	examples/cref.c	/^Text_T first, rest;$/;"	v
first	examples/iref.c	/^Text_T first, rest;$/;"	v
first	examples/kref.c	/^char *first, *rest;$/;"	v
first	examples/wf.c	/^int first(int c) {$/;"	f
first	examples/xref.c	/^int first(int c) {$/;"	f
first	include/list.h	/^	void *first;$/;"	m	struct:T
fmt	examples/mpcalc.c	/^	char *fmt;$/;"	m	struct:__anon2	file:
free	src/memchk.c	/^	struct descriptor *free;$/;"	m	struct:descriptor	typeref:struct:descriptor::descriptor	file:
freechunks	src/arena.c	/^static T freechunks;$/;"	v	file:
freelist	src/memchk.c	/^static struct descriptor freelist = { &freelist };$/;"	v	typeref:struct:descriptor	file:
freelist	src/thread.c	/^static T freelist;$/;"	v	file:
get	src/thread.c	/^static T get(T *q) {$/;"	f	file:
getThreadByID	src/thread-nt.c	/^static T getThreadByID(DWORD id) {$/;"	f	file:
getword	examples/cref.c	/^Text_T getword(Text_T *line, Text_T first, Text_T rest) {$/;"	f
getword	examples/double.c	/^int getword(FILE *fp, char *buf, int size) {$/;"	f
getword	examples/getword.c	/^int getword(FILE *fp, char *buf, int size,$/;"	f
getword	examples/iref.c	/^Text_T getword(Text_T *line, Text_T first, Text_T rest) {$/;"	f
getword	examples/kref.c	/^int getword(char *line, int *i, char *first, char *rest) {$/;"	f
handle	src/thread-nt.c	/^	T handle;		\/* self pointer *\/$/;"	m	struct:T	file:
handle	src/thread.c	/^	T handle;$/;"	m	struct:T	file:
hash	src/memchk.c	/^#define hash(/;"	d	file:
hash	src/set.c	/^	unsigned (*hash)(const void *x);$/;"	m	struct:T	file:
hash	src/table.c	/^	unsigned (*hash)(const void *key);$/;"	m	struct:T	file:
hashatom	src/set.c	/^static unsigned hashatom(const void *x) {$/;"	f	file:
hashatom	src/table.c	/^static unsigned hashatom(const void *key) {$/;"	f	file:
head	src/ring.c	/^	} *head;$/;"	m	struct:T	typeref:struct:T::node	file:
head	src/seq.c	/^	int head;$/;"	m	struct:T	file:
head	src/stack.c	/^	} *head;$/;"	m	struct:T	typeref:struct:T::elem	file:
head	src/text.c	/^} head = { NULL, NULL, NULL }, *current = &head;$/;"	v	typeref:struct:chunk	file:
header	src/arena.c	/^union header {$/;"	u	file:
htab	src/memchk.c	/^} *htab[2048];$/;"	v	typeref:struct:descriptor	file:
ibase	examples/mpcalc.c	/^int ibase = 10;$/;"	v
idx	src/str.c	/^#define idx(/;"	d	file:
idx	src/text.c	/^#define idx(/;"	d	file:
inqueue	src/thread.c	/^	T *inqueue;$/;"	m	struct:T	file:
insert	src/fmt.c	/^static int insert(int c, void *cl) {$/;"	f	file:
intcmp	examples/xref.c	/^int intcmp(const void *x, const void *y) {$/;"	f
interrupt	src/thread.c	/^static int interrupt(int sig, int code,$/;"	f	file:
interrupt	src/thread.c	/^static int interrupt(int sig, struct sigcontext_struct sc) {$/;"	f	file:
inthash	examples/xref.c	/^unsigned inthash(const void *x) {$/;"	f
intro	install.html	/^<H2><A NAME="intro">Introduction<\/A><\/H2>$/;"	a
ip	examples/spin.c	/^	int *ip;$/;"	m	struct:args	file:
iref	examples/iref.c	/^void iref(char *name, FILE *fp, Table_T identifiers) {$/;"	f
isatend	src/text.c	/^#define isatend(/;"	d	file:
isempty	src/thread.c	/^#define isempty(/;"	d	file:
isone	src/ap.c	/^#define isone(/;"	d	file:
iszero	src/ap.c	/^#define iszero(/;"	d	file:
iszero	src/mp.c	/^#define iszero(/;"	d	file:
join	src/thread-nt.c	/^	HANDLE join;		\/* join semaphore *\/$/;"	m	struct:T	file:
join	src/thread.c	/^	T join;$/;"	m	struct:T	file:
join0	src/thread-nt.c	/^static HANDLE join0;		\/* Thread_join(NULL) semaphore *\/$/;"	v	file:
join0	src/thread.c	/^static T join0;$/;"	v	file:
join0count	src/thread-nt.c	/^static int join0count;		\/* number of threads waiting on join0; always 0 or 1 *\/$/;"	v	file:
joinlist	src/thread-nt.c	/^	T joinlist;		\/* threads waiting on join *\/$/;"	m	struct:T	file:
key	src/table.c	/^		const void *key;$/;"	m	struct:T::binding	file:
kref	examples/kref.c	/^void kref(char *name, FILE *fp, Table_T identifiers) {$/;"	f
last	examples/sieve.c	/^	int n, last;$/;"	m	struct:args	file:
lb	examples/sort.c	/^	int lb, ub;$/;"	m	struct:args	file:
len	include/text.h	/^	int len;$/;"	m	struct:T
len	src/atom.c	/^	int len;$/;"	m	struct:atom	file:
length	include/arrayrep.h	/^	int length;$/;"	m	struct:T
length	src/bit.c	/^	int length;$/;"	m	struct:T	file:
length	src/ring.c	/^	int length;$/;"	m	struct:T	file:
length	src/seq.c	/^	int length;$/;"	m	struct:T	file:
length	src/set.c	/^	int length;$/;"	m	struct:T	file:
length	src/table.c	/^	int length;$/;"	m	struct:T	file:
limit	src/arena.c	/^	char *limit;$/;"	m	struct:T	file:
limit	src/text.c	/^	char *limit;$/;"	m	struct:chunk	file:
line	include/except.h	/^	int line;$/;"	m	struct:Except_Frame
line	src/memchk.c	/^	int line;$/;"	m	struct:descriptor	file:
linenum	examples/double.c	/^int linenum;$/;"	v
linenum	examples/xref.c	/^int linenum;$/;"	v
link	src/atom.c	/^	struct atom *link;$/;"	m	struct:atom	typeref:struct:atom::atom	file:
link	src/memchk.c	/^	struct descriptor *link;$/;"	m	struct:descriptor	typeref:struct:descriptor::descriptor	file:
link	src/set.c	/^		struct member *link;$/;"	m	struct:T::member	typeref:struct:T::member::member	file:
link	src/stack.c	/^		struct elem *link;$/;"	m	struct:T::elem	typeref:struct:T::elem::elem	file:
link	src/table.c	/^		struct binding *link;$/;"	m	struct:T::binding	typeref:struct:T::binding::binding	file:
link	src/text.c	/^	struct chunk *link;$/;"	m	struct:chunk	typeref:struct:chunk::chunk	file:
link	src/thread-nt.c	/^	T link;			\/* next thread on this join list *\/$/;"	m	struct:T	file:
link	src/thread.c	/^	T link;$/;"	m	struct:T	file:
llink	src/ring.c	/^		struct node *llink, *rlink;$/;"	m	struct:T::node	typeref:struct:T::node::node	file:
lsbmask	src/bit.c	/^unsigned char lsbmask[] = {$/;"	v
mailinglist	install.html	/^<H2><A NAME="mailinglist">Keeping in Touch<\/A><\/H2>$/;"	a
main	examples/basename.c	/^int main(int argc, char *argv[]) {$/;"	f
main	examples/calc.c	/^int main(int argc, char *argv[]) {$/;"	f
main	examples/cref.c	/^int main(int argc, char *argv[]) {$/;"	f
main	examples/double.c	/^int main(int argc, char *argv[]) {$/;"	f
main	examples/idents.c	/^int main(int argc, char *argv[]) {$/;"	f
main	examples/ids.c	/^int main(int argc, char *argv[]) {$/;"	f
main	examples/iref.c	/^int main(int argc, char *argv[]) {$/;"	f
main	examples/kref.c	/^int main(int argc, char *argv[]) {$/;"	f
main	examples/mpcalc.c	/^int main(int argc, char *argv[]) {$/;"	f
main	examples/sieve.c	/^int main(int argc, char *argv[]) {$/;"	f
main	examples/sort.c	/^main(int argc, char *argv[]) {$/;"	f
main	examples/spin.c	/^int main(int argc, char *argv[]) {$/;"	f
main	examples/wf.c	/^int main(int argc, char *argv[]) {$/;"	f
main	examples/words.c	/^int main(int argc, char *argv[]) {$/;"	f
main	examples/xref.c	/^int main(int argc, char *argv[]) {$/;"	f
map	src/xp.c	/^static char map[] = {$/;"	v	file:
maxdigits	src/ap.c	/^#define maxdigits(/;"	d	file:
member	src/set.c	/^		const void *member;$/;"	m	struct:T::member	file:
member	src/set.c	/^	struct member {$/;"	s	struct:T	file:
memcmp	src/memcmp.c	/^int memcmp(const void *s1, const void *s2, size_t n) {$/;"	f
memmove	src/memmove.c	/^void *memmove(void *s1, const void *s2, size_t n) {$/;"	f
mk	src/ap.c	/^static T mk(int size) {$/;"	f	file:
mod	examples/mpcalc.c	/^	MP_T (*mod)(MP_T, MP_T, MP_T);$/;"	m	struct:__anon2	file:
msb	src/mp.c	/^static unsigned char msb = 0xFF;$/;"	v	file:
msbmask	src/bit.c	/^unsigned char msbmask[] = {$/;"	v
mul	examples/mpcalc.c	/^	MP_T (*mul)(MP_T, MP_T, MP_T);$/;"	m	struct:__anon2	file:
mulmod	src/ap.c	/^static T mulmod(T x, T y, T p) {$/;"	f	file:
mutex	examples/spin.c	/^	Sem_T *mutex;$/;"	m	struct:args	file:
n	examples/sieve.c	/^	int n, last;$/;"	m	struct:args	file:
n	examples/spin.c	/^int n;$/;"	v
nbits	src/mp.c	/^static int nbits  =  32;$/;"	v	file:
nbytes	src/bit.c	/^#define nbytes(/;"	d	file:
nbytes	src/mp.c	/^static int nbytes = (32-1)\/8 + 1;$/;"	v	file:
ndigits	src/ap.c	/^	int ndigits;$/;"	m	struct:T	file:
next	src/thread-nt.c	/^	T next;			\/* next thread on this hash chain *\/$/;"	m	struct:T	file:
next	src/thread.c	/^	T next;$/;"	m	struct:T	file:
nfree	src/arena.c	/^static int nfree;$/;"	v	file:
node	src/ring.c	/^	struct node {$/;"	s	struct:T	file:
normalize	src/ap.c	/^static T normalize(T z, int n) {$/;"	f	file:
nthreads	src/thread-nt.c	/^static int nthreads;		\/* number of threads in allthreads *\/$/;"	v	file:
nthreads	src/thread.c	/^static int nthreads;$/;"	v	file:
nwords	src/bit.c	/^#define nwords(/;"	d	file:
obase	examples/mpcalc.c	/^int obase = 10;$/;"	v
ones	src/mp.c	/^#define ones(/;"	d	file:
outc	src/fmt.c	/^static int outc(int c, void *cl) {$/;"	f	file:
pad	src/arena.c	/^	char pad[MAXALIGN];$/;"	m	union:align	file:
pad	src/fmt.c	/^#define pad(/;"	d	file:
pad	src/memchk.c	/^	char pad[MAXALIGN];$/;"	m	union:align	file:
partition	examples/sort.c	/^int partition(int a[], int i, int j) {$/;"	f
pop	examples/calc.c	/^AP_T pop(void) {$/;"	f
pop	examples/mpcalc.c	/^MP_T pop(void) {$/;"	f
prev	include/except.h	/^	Except_Frame *prev;$/;"	m	struct:Except_Frame
prev	src/arena.c	/^	T prev;$/;"	m	struct:T	file:
print	examples/cref.c	/^void print(Table_T files) {$/;"	f
print	examples/iref.c	/^void print(Table_T files) {$/;"	f
print	examples/kref.c	/^void print(Table_T files) {$/;"	f
print	examples/xref.c	/^void print(Table_T files) {$/;"	f
ptr	src/chan.c	/^	const void *ptr;$/;"	m	struct:T	file:
ptr	src/memchk.c	/^	const void *ptr;$/;"	m	struct:descriptor	file:
put	src/thread.c	/^static void put(T t, T *q) {$/;"	f	file:
queue	include/sem.h	/^	void *queue;$/;"	m	struct:T
quick	examples/sort.c	/^int quick(void *cl) {$/;"	f
rcsid	examples/calc.c	/^static char rcsid[] = "$Id: H:\/drh\/idioms\/book\/RCS\/ap.doc,v 1.11 1996\/06\/26 23:02:01 drh Exp $";$/;"	v	file:
rcsid	examples/cref.c	/^static char rcsid[] = "$Id: cref.c,v 1.3 1997\/07\/30 22:41:03 drh Exp $";$/;"	v	file:
rcsid	examples/double.c	/^static char rcsid[] = "$Id: H:\/drh\/idioms\/book\/RCS\/intro.doc,v 1.12 1997\/10\/27 23:05:12 drh Exp $";$/;"	v	file:
rcsid	examples/getword.c	/^static char rcsid[] = "$Id: H:\/drh\/idioms\/book\/RCS\/table.doc,v 1.13 1997\/10\/27 23:10:11 drh Exp $";$/;"	v	file:
rcsid	examples/ids.c	/^static char rcsid[] = "$Id: H:\/drh\/idioms\/book\/RCS\/str.doc,v 1.10 1996\/06\/26 23:02:01 drh Exp $";$/;"	v	file:
rcsid	examples/iref.c	/^static char rcsid[] = "$Id: iref.c,v 1.3 1997\/07\/30 22:41:04 drh Exp $";$/;"	v	file:
rcsid	examples/kref.c	/^static char rcsid[] = "$Id: kref.c,v 1.3 1997\/07\/30 22:41:04 drh Exp $";$/;"	v	file:
rcsid	examples/mpcalc.c	/^static char rcsid[] = "$Id: H:\/drh\/idioms\/book\/RCS\/mp.doc,v 1.11 1996\/06\/26 23:02:01 drh Exp $";$/;"	v	file:
rcsid	examples/sieve.c	/^static char rcsid[] = "$Id: H:\/drh\/idioms\/book\/RCS\/thread.doc,v 1.11 1997\/02\/21 19:50:51 drh Exp $";$/;"	v	file:
rcsid	examples/sort.c	/^static char rcsid[] = "$Id: H:\/drh\/idioms\/book\/RCS\/thread.doc,v 1.11 1997\/02\/21 19:50:51 drh Exp $";$/;"	v	file:
rcsid	examples/spin.c	/^static char rcsid[] = "$Id: H:\/drh\/idioms\/book\/RCS\/thread.doc,v 1.11 1997\/02\/21 19:50:51 drh Exp $";$/;"	v	file:
rcsid	examples/wf.c	/^static char rcsid[] = "$Id: H:\/drh\/idioms\/book\/RCS\/table.doc,v 1.13 1997\/10\/27 23:10:11 drh Exp $";$/;"	v	file:
rcsid	examples/xref.c	/^static char rcsid[] = "$Id: H:\/drh\/idioms\/book\/RCS\/set.doc,v 1.11 1996\/06\/26 23:02:01 drh Exp $";$/;"	v	file:
rcsid	src/ap.c	/^static char rcsid[] = "$Id: H:\/drh\/idioms\/book\/RCS\/ap.doc,v 1.11 1996\/06\/26 23:02:01 drh Exp $";$/;"	v	file:
rcsid	src/arena.c	/^static char rcsid[] = "$Id: H:\/drh\/idioms\/book\/RCS\/arena.doc,v 1.10 1997\/02\/21 19:45:19 drh Exp $";$/;"	v	file:
rcsid	src/arith.c	/^static char rcsid[] = "$Id: H:\/drh\/idioms\/book\/RCS\/inter.doc,v 1.11 1997\/02\/21 19:42:15 drh Exp $";$/;"	v	file:
rcsid	src/array.c	/^static char rcsid[] = "$Id: H:\/drh\/idioms\/book\/RCS\/array.doc,v 1.11 1997\/10\/29 22:05:21 drh Exp $";$/;"	v	file:
rcsid	src/assert.c	/^static char rcsid[] = "$Id: H:\/drh\/idioms\/book\/RCS\/except.doc,v 1.10 1997\/02\/21 19:43:55 drh Exp $";$/;"	v	file:
rcsid	src/atom.c	/^static char rcsid[] = "$Id: H:\/drh\/idioms\/book\/RCS\/atom.doc,v 1.10 1997\/02\/21 19:42:46 drh Exp $";$/;"	v	file:
rcsid	src/bit.c	/^static char rcsid[] = "$Id: H:\/drh\/idioms\/book\/RCS\/bit.doc,v 1.15 1997\/02\/21 19:49:56 drh Exp $";$/;"	v	file:
rcsid	src/chan.c	/^static char rcsid[] = "$Id: H:\/drh\/idioms\/book\/RCS\/thread.doc,v 1.11 1997\/02\/21 19:50:51 drh Exp $";$/;"	v	file:
rcsid	src/except.c	/^static char rcsid[] = "$Id: H:\/drh\/idioms\/book\/RCS\/except.doc,v 1.10 1997\/02\/21 19:43:55 drh Exp $";$/;"	v	file:
rcsid	src/fmt.c	/^static char rcsid[] = "$Id: H:\/drh\/idioms\/book\/RCS\/fmt.doc,v 1.10 1996\/06\/26 23:02:01 drh Exp $";$/;"	v	file:
rcsid	src/list.c	/^static char rcsid[] = "$Id: H:\/drh\/idioms\/book\/RCS\/list.doc,v 1.11 1997\/02\/21 19:46:01 drh Exp $";$/;"	v	file:
rcsid	src/mem.c	/^static char rcsid[] = "$Id: H:\/drh\/idioms\/book\/RCS\/mem.doc,v 1.12 1997\/10\/27 23:08:05 drh Exp $";$/;"	v	file:
rcsid	src/memchk.c	/^static char rcsid[] = "$Id: H:\/drh\/idioms\/book\/RCS\/mem.doc,v 1.12 1997\/10\/27 23:08:05 drh Exp $";$/;"	v	file:
rcsid	src/mp.c	/^static char rcsid[] = "$Id: H:\/drh\/idioms\/book\/RCS\/mp.doc,v 1.11 1996\/06\/26 23:02:01 drh Exp $";$/;"	v	file:
rcsid	src/ring.c	/^static char rcsid[] = "$Id: H:\/drh\/idioms\/book\/RCS\/ring.doc,v 1.12 1997\/02\/21 19:49:24 drh Exp $";$/;"	v	file:
rcsid	src/seq.c	/^static char rcsid[] = "$Id: H:\/drh\/idioms\/book\/RCS\/seq.doc,v 1.11 1997\/02\/21 19:48:24 drh Exp $";$/;"	v	file:
rcsid	src/set.c	/^static char rcsid[] = "$Id: H:\/drh\/idioms\/book\/RCS\/set.doc,v 1.11 1996\/06\/26 23:02:01 drh Exp $";$/;"	v	file:
rcsid	src/stack.c	/^static char rcsid[] = "$Id: H:\/drh\/idioms\/book\/RCS\/inter.doc,v 1.11 1997\/02\/21 19:42:15 drh Exp $";$/;"	v	file:
rcsid	src/str.c	/^static char rcsid[] = "$Id: H:\/drh\/idioms\/book\/RCS\/str.doc,v 1.10 1996\/06\/26 23:02:01 drh Exp $";$/;"	v	file:
rcsid	src/table.c	/^static char rcsid[] = "$Id: H:\/drh\/idioms\/book\/RCS\/table.doc,v 1.13 1997\/10\/27 23:10:11 drh Exp $";$/;"	v	file:
rcsid	src/text.c	/^static char rcsid[] = "$Id: H:\/drh\/idioms\/book\/RCS\/text.doc,v 1.10 1996\/06\/26 23:02:01 drh Exp $";$/;"	v	file:
rcsid	src/thread-nt.c	/^static char rcsid[] = "$Id: thread-nt.c,v 1.5 1997\/07\/29 17:10:25 drh Exp $";$/;"	v	file:
rcsid	src/thread.c	/^static char rcsid[] = "$Id: H:\/drh\/idioms\/book\/RCS\/thread.doc,v 1.11 1997\/02\/21 19:50:51 drh Exp $";$/;"	v	file:
rcsid	src/xp.c	/^static char rcsid[] = "$Id: H:\/drh\/idioms\/book\/RCS\/xp.doc,v 1.10 1996\/06\/26 23:02:01 drh Exp $";$/;"	v	file:
ready	src/thread.c	/^static T ready = NULL;$/;"	v	file:
reason	include/except.h	/^	char *reason;$/;"	m	struct:T
recv	src/chan.c	/^	Sem_T send, recv, sync;$/;"	m	struct:T	file:
release	src/thread.c	/^static void release(void) {$/;"	f	file:
removeThread	src/thread-nt.c	/^static void removeThread(T t) {$/;"	f	file:
rest	examples/cref.c	/^Text_T first, rest;$/;"	v
rest	examples/iref.c	/^Text_T first, rest;$/;"	v
rest	examples/kref.c	/^char *first, *rest;$/;"	v
rest	examples/wf.c	/^int rest(int c) {$/;"	f
rest	examples/xref.c	/^int rest(int c) {$/;"	f
rest	include/list.h	/^	T rest;$/;"	m	struct:T
rlink	src/ring.c	/^		struct node *llink, *rlink;$/;"	m	struct:T::node	typeref:struct:T::node::	file:
root	src/thread-nt.c	/^static T root;$/;"	v	file:
root	src/thread.c	/^static struct Thread_T root;$/;"	v	typeref:struct:Thread_T	file:
run	src/thread.c	/^static void run(void) {$/;"	f	file:
s	examples/mpcalc.c	/^} s = { "%D\\n",$/;"	v	typeref:struct:__anon2
safe	examples/spin.c	/^int safe(void *cl) {$/;"	f
scatter	src/atom.c	/^static unsigned long scatter[] = {$/;"	v	file:
send	src/chan.c	/^	Sem_T send, recv, sync;$/;"	m	struct:T	file:
set	src/ap.c	/^static T set(T z, long int n) {$/;"	f	file:
setop	src/bit.c	/^#define setop(/;"	d	file:
shft	src/mp.c	/^#define shft(/;"	d	file:
shift	src/mp.c	/^static int shift  = (32-1)%8;$/;"	v	file:
sign	src/ap.c	/^	int sign;$/;"	m	struct:T	file:
sign	src/mp.c	/^#define sign(/;"	d	file:
sink	examples/sieve.c	/^int sink(void *cl) {$/;"	f
size	include/arrayrep.h	/^	int size;$/;"	m	struct:T
size	src/ap.c	/^	int size;$/;"	m	struct:T	file:
size	src/chan.c	/^	int *size;$/;"	m	struct:T	file:
size	src/fmt.c	/^	int size;$/;"	m	struct:buf	file:
size	src/memchk.c	/^	long size;$/;"	m	struct:descriptor	file:
size	src/set.c	/^	int size;$/;"	m	struct:T	file:
size	src/table.c	/^	int size;$/;"	m	struct:T	file:
sort	examples/sort.c	/^void sort(int *x, int n, int argc, char *argv[]) {$/;"	f
source	examples/sieve.c	/^int source(void *cl) {$/;"	f
sp	examples/calc.c	/^Stack_T sp;$/;"	v
sp	examples/mpcalc.c	/^Seq_T sp;$/;"	v
sp	src/thread.c	/^	unsigned long *sp;						\/* must be first *\/$/;"	m	struct:T	file:
start	src/thread-nt.c	/^static unsigned __stdcall start(void *p) {$/;"	f	file:
str	include/text.h	/^	const char *str;$/;"	m	struct:T
str	src/atom.c	/^	char *str;$/;"	m	struct:atom	file:
strerror	src/strerror.c	/^char *strerror(int errnum) {$/;"	f
strhash	examples/kref.c	/^unsigned strhash(const void *x) {$/;"	f
strncmp	src/strncmp.c	/^int strncmp(const char *s1, const char *s2, size_t n) {$/;"	f
sub	examples/mpcalc.c	/^	MP_T (*sub)(MP_T, MP_T, MP_T);$/;"	m	struct:__anon2	file:
sub	src/ap.c	/^static T sub(T z, T x, T y) {$/;"	f	file:
sync	src/chan.c	/^	Sem_T send, recv, sync;$/;"	m	struct:T	file:
temp	src/mp.c	/^static unsigned char temp[16 + 16 + 16 + 2*16+2];$/;"	v	file:
testalert	src/thread-nt.c	/^static void testalert(T t) {$/;"	f	file:
testalert	src/thread.c	/^static void testalert(void) {$/;"	f	file:
textcmp	examples/cref.c	/^int textcmp(const void *x, const void *y) {$/;"	f
textcmp	examples/iref.c	/^int textcmp(const void *x, const void *y) {$/;"	f
texthash	examples/cref.c	/^unsigned texthash(const void *x) {$/;"	f
texthash	examples/iref.c	/^unsigned texthash(const void *x) {$/;"	f
timestamp	src/set.c	/^	unsigned timestamp;$/;"	m	struct:T	file:
timestamp	src/table.c	/^	unsigned timestamp;$/;"	m	struct:T	file:
tmp	src/mp.c	/^static T tmp[] = {temp, temp+1*16, temp+2*16, temp+3*16};$/;"	v	file:
u	examples/mpcalc.c	/^  u = { "%U\\n",$/;"	v	typeref:struct:__anon2
ub	examples/sort.c	/^	int lb, ub;$/;"	m	struct:args	file:
unix	install.html	/^<H2><A NAME="unix">Installation on UNIX<\/A><\/H2>$/;"	a
unsafe	examples/spin.c	/^int unsafe(void *cl) {$/;"	f
value	src/ring.c	/^		void *value;$/;"	m	struct:T::node	file:
value	src/table.c	/^		void *value;$/;"	m	struct:T::binding	file:
vfree	examples/wf.c	/^void vfree(const void *key, void **count, void *cl) {$/;"	f
wf	examples/wf.c	/^void wf(char *name, FILE *fp) {$/;"	f
win32	install.html	/^<H2><A NAME="win32">Installation on Windows 95\/NT<\/A><\/H2>$/;"	a
words	src/bit.c	/^	unsigned long *words;$/;"	m	struct:T	file:
x	src/mp.c	/^static int apply(T op(T, T, T), T z, T x, long v) {$/;"	v	file:
x	src/mp.c	/^static int applyu(T op(T, T, T), T z, T x,$/;"	v	file:
x	src/stack.c	/^		void *x;$/;"	m	struct:T::elem	file:
xref	examples/xref.c	/^void xref(const char *name, FILE *fp,$/;"	f
z	src/mp.c	/^static int apply(T op(T, T, T), T z, T x, long v) {$/;"	v	file:
z	src/mp.c	/^static int applyu(T op(T, T, T), T z, T x,$/;"	v	file:
